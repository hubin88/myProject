<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function Cat(name, color) {
					this.name = name;
					this.color = color;
				} //构造猫的原型对象，每只猫有不同的属性
			Cat.prototype.type = "猫科动物";
			Cat.prototype.eat = function() {
				alert("吃老鼠")
			};
			 //所有的猫共有的属性，直接定义在prototype属性上，避免内存浪费。
			var cat1 = new Cat("大毛", "黄色");
			var cat2 = new Cat("二毛", "黑色");
			 //		alert(cat1.name);//大毛
			 //		alert(cat2.name);//二毛
			 //		alert(cat1.type);//猫科动物
			 //		cat2.eat();//吃老鼠
			 //		alert(cat1.constructor==Cat);//true
			 //		alert(cat2.constructor==Cat);//true
			 //		alert(cat1.eat == cat2.eat); //true
			 //cat1和cat2会自动生成含有一个constructor属性，指向构造函数Cat。
			 //isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。
			 //		alert(Cat.prototype.isPrototypeOf(cat1)); //true
			 //		alert(Cat.prototype.isPrototypeOf(cat2)); //true
			 //instanceof判断左侧对象是否是右侧类的实例。
			 //		alert(cat1 instanceof Cat);//true
			 //		alert(cat2 instanceof Cat);//true
			 //hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
			　
			 //			alert(cat1.hasOwnProperty("name")); // true
			 //			alert(cat1.hasOwnProperty("color"));// true
			 //			alert(cat1.hasOwnProperty("type")); // false
			 //			alert(cat1.hasOwnProperty("eat"));// false
			 //			in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。in运算符还可以用来遍历某个对象的所有属性。
			　
//			alert("name" in cat1); // true
//			　　
//			alert("type" in cat1); // true
			　for(var prop in cat1) { alert("cat1["+prop+"]="+cat1[prop]); }
		</script>
	</head>

	<body>
	</body>

</html>