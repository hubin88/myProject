<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	</body>
	<script src="js/jquery-1.11.2.min.js" type="text/javascript" charset="utf-8"></script>
	<script src="js/underscore.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript">
	//first,_.first(array, [n]) 返回array（数组）的第一个元素。传递 n参数将返回数组中从第一个元素开始的n个元素（注：返回数组中前 n 个元素.）
	document.write(_.first([65,86,64,658,548,548])+"<br>");
	document.write(_.first([65,86,64,658,548,548],3)+"<br>");
	//rest,_.rest(array, [n])返回数组中除了第一个元素外的其他全部元素。传递n参数将返回从第n个元素开始的剩余所有元素 （注：排除数组前面的 n 个元素）。
	document.write(_.rest([65,86,64,658,548,548])+"<br>");
	document.write(_.rest([65,86,64,658,548,548],2)+"<br>");
	//last,_.last(array, [n])返回array（数组）的最后一个元素。传递 n参数将返回数组中从最后一个元素开始的n个元素（注：返回数组里的后面的n个元素）。 
	document.write(_.last([65,86,64,658,548,548])+"<br>");
	document.write(_.last([65,86,64,658,548,548],4)+"<br>");
	// initial,_.initial(array, [n])返回数组中除了最后一个元素外的其他全部元素。 在arguments对象上特别有用。传递 n参数将从结果中排除从最后一个开始的n个元素（注：排除数组后面的 n 个元素）。
	document.write(_.initial([65,86,64,658,548,548])+"<br>");
	document.write(_.initial([65,86,64,658,548,548],2)+"<hr>");
	//compact,_.compact(array)返回一个除去所有false值的 array副本。 在javascript中, false, null, 0, "", undefined 和 NaN 都是false值. 
	document.write(_.compact([1,false,2,null,3,0,undefined,NaN])+"<br>");
	//without,_.without(array, *values)返回一个删除所有values值后的 array副本。（注：使用===表达式做相等测试。） 
	document.write(_.without([65,86,64,658,548,548],65,64)+"<br>");
	//difference,_.difference(array, *others)类似于without，但返回的值来自array参数数组，并且不存在于other 数组(求差集). 
	document.write(_.difference([65,86,64,658,548,548],[65,23,1],[658,85])+"<br>");
	//union,_.union(*arrays)返回传入的 arrays（数组）并集：按顺序返回，返回数组的元素是唯一的即不会重复，可以传入一个或多个 arrays（数组）
	document.write(_.union([1,2,3,4],[3,5,65,4],[32,1,65,44,12],[2,4,8])+"<br>");
	//intersection,_.intersection(*arrays)返回传入 arrays（数组）交集。结果中的每个值是存在于传入的每个arrays（数组）里。 
	document.write(_.intersection([1,2,2,3,4],[3,5,2,2,65,4],[2,4,8,3,2])+"<br>");
	//uniq,_.uniq(array)返回 array去重后的副本, 使用 === 做相等测试.
	document.write(_.uniq([12,23,34,34,"我","我",34,12,56,"add",12,"dsa","我","add","dqd","add"])+"<br>");
	//zip,_.zip(*arrays)将 每个arrays中相应位置的值合并在一起。在合并分开保存的数据时很有用. 如果你用来处理矩阵嵌套数组时, _.zip.apply 可以做类似的效果。 
	document.write(_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false])+"<br>")
	document.write(_.zip.apply(_,[['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]])+"<hr>");
	//object,_.object(list, [values])将数组转换为对象。传递任何一个单独[key, value]对的列表，或者一个键的列表和一个值得列表。 如果存在重复键，最后一个值将被返回。 
	_.object(['moe', 'larry', 'curly'], [30, 40, 50]);
	//=> {moe: 30, larry: 40, curly: 50}
	_.object([['moe', 30], ['larry', 40], ['curly', 50]]);
	//=> {moe: 30, larry: 40, curly: 50}
	//indexOf,_.indexOf(array, value, [fromIndex])返回value在该 array 中的索引值，如果value不存在 array中就返回-1。传递fromIndex将从你给定的索性值开始搜索
	document.write(_.indexOf([65,86,64,658,548,548],64,3)+"<br>");
	document.write(_.indexOf([65,86,64,658,548,548],64)+"<br>");
	//lastIndexOf,_.lastIndexOf(array, value, [fromIndex])返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。 传递fromIndex将从你给定的索性值开始搜索
	document.write(_.lastIndexOf([65,86,548,64,658,548],548)+"<br>");
	document.write(_.lastIndexOf([65,86,548,64,658,548],548,4)+"<br>");
	//sortedIndex_.sortedIndex(list, value, [iteratee], [context])使用二分查找确定value在list中的位置序号，value按此序号插入能保持list原有的排序。 如果提供iterator函数，iterator将作为list排序的依据，包括你传递的value 。 iterator也可以是字符串的属性名用来排序(比如length)。 
	document.write(_.sortedIndex([30,20,50,40,10,60],35)+"<br>");
	document.write(_.sortedIndex(_.sortBy([30,20,50,40,10,60]),35)+"<hr>");
	//range_.range([start], stop, [step])一个用来创建整数灵活编号的列表的函数，便于each 和 map循环。如果省略start则默认为 0；step 默认为 1.返回一个从start 到stop的整数的列表(不包含stop)，用step来增加 （或减少）独占。值得注意的是，如果stop值在start前面（也就是stop值小于start值），那么值域会被认为是零长度，而不是负增长。-如果你要一个负数的值域 ，请使用负数step. 
	document.write(_.range(10)+"<br>");
	document.write(_.range(1,11)+"<br>");
	document.write(_.range(5,50,5)+"<br>");
	document.write(_.range(5,51,5)+"<br>");
	document.write(_.range(50,5,-5)+"<hr>");
	</script>
	
	
</html>
